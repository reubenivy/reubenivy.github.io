<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cinematic Story</title>
    <style>
        /* ==========================================
           CSS RESET AND BODY STYLES
           ========================================== */
        body {
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            touch-action: manipulation;
            position: relative;
        }

        /* ==========================================
           CONTENT AREA AND TEXT SECTIONS
           ========================================== */
        #content-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
            height: 90vh;
            max-height: 900px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease-in-out;
            opacity: 0; /* Starts hidden, fades in */
        }

        .text-section {
            text-align: center;
            width: 100%;
        }

        .text-content {
            font-size: 2.5em;
            line-height: 1.4;
            opacity: 0;
            transition: opacity 1.5s ease;
            padding: 20px;
            max-width: 80%;
            margin: 0 auto;
        }

        .text-content.visible {
            opacity: 1;
        }

        /* ==========================================
           PHOTO SECTION STYLES
           ========================================== */
        .stack-image {
            position: absolute;
            width: 70%; 
            max-height: 80%;
            object-fit: contain;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 1s ease, transform 1s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smooth CSS transition */
            /* Initial position offset for effect */
            transform: translate(-50%, -50%) rotate(0deg) scale(0.9);
            top: 50%;
            left: 50%;
        }

        .stack-image.visible {
            opacity: 1;
            /* Final transform is set by JS with random rotation */
        }
        
        /* ==========================================
           VIDEO SECTION STYLES
           ========================================== */
        .video-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #cinematic-video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensures the entire video is visible */
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }
        
        #cinematic-video.visible {
            opacity: 1;
        }


        /* ==========================================
           UNMUTE OVERLAY (The Click Handler)
           ========================================== */
        #unmute-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            cursor: pointer;
            z-index: 1000;
            transition: opacity 1s ease;
        }

        #unmute-message {
            font-size: 1.2em;
            color: #ccc;
            padding: 20px;
            max-width: 80%;
        }

        /* Spinner Animation */
        #loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-top: 20px;
            display: none;
        }
        
        #loading-spinner.visible {
            display: block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Pulse Animation for the final ready message */
        @keyframes pulse {
            0% { color: #fff; }
            100% { color: #00ff6a; }
        }
    </style>
</head>
<body>

    <div id="content-area">
        </div>

    <div id="unmute-overlay">
        <div id="unmute-message">
            Tap anywhere to stabilize and preload media (Click 1 of 2) üëÜ
        </div>
        <div id="loading-spinner"></div>
    </div>

    <script>
        // ==========================================
        // üåü SECTION CONTROL ARRAY üåü
        // ==========================================
        const pageContent = [
            {
                type: 'text',
                content: 'Thanks for letting me meet you in 2025',
                duration: 7500,
                track: ''
            },
            // ‚≠êÔ∏è NEW VIDEO SECTION ADDED ‚≠êÔ∏è
            {
                type: 'video',
                content: 'https://reubenivy.github.io/recap_asset/wise_men_say_2.mp4', 
                duration: 77000, 
                track: '' // Video sections DO NOT use the audio track manager
            },
            // ‚≠êÔ∏è END NEW VIDEO SECTION ‚≠êÔ∏è
            {
                type: 'text',
                content: 'THE END',
                duration: 999999,
                track: ''
            },
        ];

        // ==========================================
        // CONSTANTS AND FLOW CONTROL LOGIC
        // ==========================================

        const CROSSFADE_DURATION = 2000;
        const CROSSFADE_STEPS = 50;
        const CROSSFADE_INTERVAL = CROSSFADE_DURATION / CROSSFADE_STEPS;
        const VOLUME_STEP = 1 / CROSSFADE_STEPS;
        const INITIAL_DELAY_AFTER_UNLOCK = 500;

        // üåü WAKE LOCK VARIABLE üåü
        let wakeLock = null; 
        // ‚≠êÔ∏è NEW: Video tracking variable ‚≠êÔ∏è
        let currentVideo = null; 

        const contentArea = document.getElementById('content-area');
        const unmuteOverlay = document.getElementById('unmute-overlay');
        const unmuteMessage = document.getElementById('unmute-message');
        const loadingSpinner = document.getElementById('loading-spinner');
        let currentAudio = null;
        let currentSectionIndex = 0;
        let hasStarted = false;

        const audioMap = {};
        let allUniqueTracks = [];
        // ‚≠êÔ∏è NEW: Separate collection for video URL ‚≠êÔ∏è
        let videoUrlToUnlock = null;


        function initializeAudio() {
            // Find all unique track URLs in the page content
            allUniqueTracks = [...new Set(pageContent.map(s => s.track).filter(t => t && t.endsWith('.mp3')))];
            
            // Find the video URL for preloading/unlocking
            const videoSection = pageContent.find(s => s.type === 'video');
            if (videoSection) {
                videoUrlToUnlock = videoSection.content;
            }

            // Create Audio objects for each unique track
            allUniqueTracks.forEach(trackUrl => {
                const audio = new Audio(trackUrl);
                audio.loop = true;
                audio.preload = 'auto';
                audio.volume = 0; 
                audioMap[trackUrl] = audio;
            });
        }

        // Helper Functions
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // --- WAKE LOCK FUNCTIONS (Unchanged) ---

        /**
         * üîí Attempts to acquire a Screen Wake Lock.
         */
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Screen Wake Lock acquired.');
                    
                    wakeLock.addEventListener('release', () => {
                        console.log('Screen Wake Lock released by system.');
                    });

                } catch (err) {
                    console.error(`Wake Lock error: ${err.name}, ${err.message}`);
                }
            } else {
                console.warn('Wake Lock API not supported by this browser/device.');
            }
        }

        /**
         * üîì Attempts to release the Screen Wake Lock.
         */
        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release()
                    .then(() => {
                        console.log('Screen Wake Lock successfully released.');
                        wakeLock = null;
                    })
                    .catch((err) => {
                        console.error('Failed to release Wake Lock:', err);
                    });
            }
        }
        
        // --- AUDIO/VIDEO UNLOCK FUNCTIONS (Modified to include video) ---

        /**
         * HACK: Sequentially plays and immediately pauses a single media track.
         */
        function unlockTrackSequentially(mediaElement) {
            return new Promise(resolve => {
                if (!mediaElement) return resolve();

                // Play the track. Since 'muted' is true, this is silent.
                mediaElement.play().then(() => {
                    mediaElement.pause();
                    mediaElement.currentTime = 0;
                    resolve();
                }).catch(e => {
                    console.warn("Track failed to unlock/play (expected if silent):", e);
                    resolve(); 
                });
            });
        }
        
        /**
         * Loops through all media sequentially to unlock them.
         * ‚≠êÔ∏è CRITICAL FIX APPLIED HERE: Keeps temp video permanently muted and removes it. ‚≠êÔ∏è
         */
        async function runSequentialUnlock() {
            // State 1: Loading
            unmuteMessage.innerHTML = 'Preloading and stabilizing media...';
            unmuteMessage.style.animation = 'none';
            loadingSpinner.classList.add('visible');
            
            let tempVideo = null;
            if (videoUrlToUnlock) {
                tempVideo = document.createElement('video');
                tempVideo.src = videoUrlToUnlock;
                // CRITICAL: Must be MUTED here for the silent unlock.
                tempVideo.muted = true; 
                tempVideo.preload = 'auto';
                tempVideo.playsInline = true; 
                
                // Keep it invisible and off-screen, but in the DOM
                tempVideo.style.position = 'absolute';
                tempVideo.style.top = '-10000px'; 
                tempVideo.style.left = '-10000px'; 
                tempVideo.style.width = '1px';
                tempVideo.style.height = '1px';
                tempVideo.style.opacity = '0';
                
                document.body.appendChild(tempVideo); // Add to DOM
                console.log("Temporary video element added to DOM off-screen.");
            }

            // Combine audio and video elements
            let allMedia = [...allUniqueTracks.map(url => audioMap[url])];
            if (tempVideo) {
                allMedia.push(tempVideo);
            }

            // CRITICAL STEP A: Force mute all media tracks for silent unlock
            for (const media of allMedia) {
                if (media) {
                    // Only the actual Audio elements need to be toggled to unmuted=false later
                    if (media.tagName === 'AUDIO') {
                        media.muted = true;
                    }
                }
            }

            // Perform the sequential unlock
            for (const media of allMedia) {
                if (media) {
                    await unlockTrackSequentially(media);
                }
            }
            
            // CRITICAL STEP B: Set final state for media and force pause
            for (const media of allMedia) {
                if (media) {
                    // Re-allow sound on real audio tracks (still volume 0)
                    if (media.tagName === 'AUDIO') {
                         media.muted = false; 
                    }
                    
                    // Force pause all tracks immediately
                    media.pause(); 
                    media.currentTime = 0;
                }
            }
            
            // ‚≠êÔ∏è FINAL CRITICAL STEP: Remove the temporary video element from the DOM ‚≠êÔ∏è
            if (tempVideo && document.body.contains(tempVideo)) {
                document.body.removeChild(tempVideo);
                console.log("Temporary video element removed from DOM.");
            }


            // State 2: Ready
            unmuteMessage.innerHTML = '‚úÖ Loading Complete. Tap to Begin Story üé¨ (Click 2 of 2)';
            unmuteMessage.style.animation = 'pulse 1.5s infinite alternate';
            loadingSpinner.classList.remove('visible');
            
            // Re-enable the click handler for the second step
            unmuteOverlay.addEventListener('click', startCinematicStorySequence, { once: true });
        }


        // üé∂ Music Crossfade Logic üé∂ 
        function playTrack(filename) {
            const previousAudio = currentAudio;

            // ‚≠êÔ∏è NEW: Stop any playing video before starting a track ‚≠êÔ∏è
            if (currentVideo) {
                currentVideo.pause();
                currentVideo.remove(); // Also remove the element
                currentVideo = null;
            }

            // Get the preloaded audio element
            const newAudio = audioMap[filename];
            if (!newAudio) {
                if (previousAudio) {
                    previousAudio.pause();
                    previousAudio.volume = 0;
                    previousAudio.currentTime = 0;
                    currentAudio = null;
                }
                return;
            }

            if (previousAudio && previousAudio === newAudio) {
                return;
            }

            currentAudio = newAudio;
            
            // Start playing the new audio, it is unblocked, unmuted, and at volume 0
            newAudio.play().then(() => {
                // Play started successfully, proceed with fade logic
            }).catch(error => {
                console.error(`Playback error on track switch for ${filename}:`, error);
            });

            if (previousAudio) {
                let currentStep = 0;

                const crossfadeTimer = setInterval(() => {
                    currentStep++;

                    // 1. Fade OLD track out
                    if (previousAudio.volume > VOLUME_STEP) {
                        previousAudio.volume -= VOLUME_STEP;
                    } else {
                        previousAudio.volume = 0;
                    }

                    // 2. Fade NEW track in
                    if (newAudio.volume < 1 - VOLUME_STEP) {
                        newAudio.volume += VOLUME_STEP;
                    } else {
                        newAudio.volume = 1;
                    }

                    // 3. Stop when fade is complete
                    if (currentStep >= CROSSFADE_STEPS) {
                        clearInterval(crossfadeTimer);
                        // Ensure old track is completely stopped and reset
                        previousAudio.pause();
                        previousAudio.volume = 0;
                        previousAudio.currentTime = 0; 
                    }
                }, CROSSFADE_INTERVAL);

            } else {
                // First track: simple fade-in
                let currentVolume = 0;
                const fadeInTimer = setInterval(() => {
                    currentVolume += VOLUME_STEP;
                    if (currentVolume >= 1) {
                        newAudio.volume = 1;
                        clearInterval(fadeInTimer);
                    } else {
                        newAudio.volume = currentVolume;
                    }
                }, CROSSFADE_INTERVAL);
            }
        }


        // Rendering Functions 
        function renderTextSection(text) {
            contentArea.innerHTML = `
                <div class="text-section">
                    <div class="text-content" id="fading-text">${text}</div>
                </div>
            `;
            // ‚≠êÔ∏è NEW: Clean up any playing video ‚≠êÔ∏è
            if (currentVideo) {
                currentVideo.pause();
                currentVideo.remove(); // Also remove the element
                currentVideo = null;
            }
            setTimeout(() => {
                document.getElementById('fading-text').classList.add('visible');
            }, 50);
        }

        function renderPhotoSection(imageUrls, delayMs) {
            contentArea.innerHTML = '';
            // ‚≠êÔ∏è NEW: Clean up any playing video ‚≠êÔ∏è
            if (currentVideo) {
                currentVideo.pause();
                currentVideo.remove(); // Also remove the element
                currentVideo = null;
            }

            const orderedImages = [...imageUrls];

            orderedImages.forEach((imgUrl, index) => {
                const img = document.createElement('img');
                img.src = imgUrl;
                img.classList.add('stack-image');

                const randomRotation = getRandomInt(-8, 8);
                contentArea.appendChild(img);

                img.onload = () => {
                    setTimeout(() => {
                        img.offsetHeight;
                        img.classList.add('visible');
                        img.style.transform = `translate(-50%, -50%) rotate(${randomRotation}deg)`;
                    }, index * delayMs);
                };
            });
        }
        
        /**
         * ‚≠êÔ∏è NEW: Render Video Section function 
         * CRITICAL FIX: Ensure video element is created as Muted. Unmute *only* after successful play().
         */
        function renderVideoSection(videoUrl, duration) {
            contentArea.innerHTML = `
                <div class="video-container">
                    <video id="cinematic-video" src="${videoUrl}" autoplay playsinline preload="auto" muted></video>
                </div>
            `;
            
            // Stop current audio (no crossfade, immediate stop)
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.volume = 0;
                currentAudio = null;
            }

            currentVideo = document.getElementById('cinematic-video');
            currentVideo.classList.add('visible');
            
            let videoTimeoutId = null;
            let hasMovedToNextSection = false;

            function moveToNextSectionSafely() {
                if (hasMovedToNextSection) return;
                hasMovedToNextSection = true;
                
                if (videoTimeoutId) clearTimeout(videoTimeoutId);
                
                nextSection(); 
            }

            // 1. ADD ENDED LISTENER: Move to the next section when the video completes.
            currentVideo.addEventListener('ended', function handleVideoEnd() {
                console.log("Video playback ended. Moving to next section.");
                moveToNextSectionSafely();
            }, { once: true });

            // 2. ATTEMPT PLAYBACK 
            currentVideo.play().then(() => {
                // Success: Video is playing (it should be muted due to the element attribute).
                console.log("Video played successfully. Attempting to unmute.");
                
                // ‚≠êÔ∏è CRITICAL FIX: Since the video is unlocked by the user's first click, 
                // the browser *should* now allow the script to unmute it.
                currentVideo.muted = false; 
                currentVideo.volume = 1;  
                
                // 3. FALLBACK TIMEOUT: If 'ended' event doesn't fire or video stops/fails silently.
                videoTimeoutId = setTimeout(() => {
                    console.warn("Video duration timeout reached. Moving to next section (Fallback).");
                    if (currentVideo) currentVideo.pause();
                    moveToNextSectionSafely();
                }, duration);

            }).catch(error => {
                // Failure: If play fails (very rare now), it's a catastrophic error.
                console.error("Video Autoplay Failed:", error);
                
                // Attempt muted fallback, just in case, but rely on the timer to move on.
                currentVideo.muted = true;
                currentVideo.volume = 0; 
                
                currentVideo.play().then(() => {
                    console.log("Video is playing successfully (Muted Fallback).");
                    videoTimeoutId = setTimeout(() => {
                        console.warn("Muted video fallback duration timeout reached. Moving to next section.");
                        if (currentVideo) currentVideo.pause();
                        moveToNextSectionSafely();
                    }, duration); 
                }).catch(e => {
                    // Catastrophic Failure: Cannot play even muted. Immediately move on.
                    console.error("Video Autoplay Failed, even muted. Skipping section.", e);
                    moveToNextSectionSafely();
                });
            });
        }


        // Main Flow Control (Modified for video)
        function nextSection() {
            if (currentSectionIndex >= pageContent.length) {
                // STORY ENDED
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.volume = 0;
                }
                // ‚≠êÔ∏è NEW: Stop video on story end ‚≠êÔ∏è
                if (currentVideo) {
                    currentVideo.pause();
                }
                // üîì RELEASE THE WAKE LOCK WHEN THE STORY IS OVER
                releaseWakeLock(); 
                return;
            }

            const section = pageContent[currentSectionIndex];
            const previousSection = pageContent[currentSectionIndex - 1];

            // 1. Play the new track (Crossfade Logic) - ONLY if it's an audio track and NOT a video section
            if (section.type !== 'video' && section.track) {
                playTrack(section.track);
            } else if (section.type !== 'video' && currentAudio) {
                currentAudio.pause();
                currentAudio.volume = 0;
                currentAudio = null; 
            }

            // --- LOGIC FOR CONTENT TRANSITIONS ---
            let isContinuousSection = false;
            // The continuity check is likely fine as is for Text -> Photos, but ensure it doesn't run during Video transition
            if (currentSectionIndex > 0 && previousSection && previousSection.type === 'text' && section.type === 'photos' && previousSection.track === section.track) {
                isContinuousSection = true;
            }

            // 2. Determine if we need to fade out previous content
            if (!isContinuousSection) {
                contentArea.style.opacity = 0;
            }

            // 3. Set the delay based on continuity
            const renderDelay = isContinuousSection ? 50 : 1000;

            setTimeout(() => {

                // 4. Render new content
                if (section.type === 'text') {
                    renderTextSection(section.content);
                } else if (section.type === 'photos') {
                    const photoDelay = section.photoDelay || 3000;
                    renderPhotoSection(section.content, photoDelay);
                } else if (section.type === 'video') {
                    // ‚≠êÔ∏è NEW VIDEO RENDER ‚≠êÔ∏è
                    renderVideoSection(section.content, section.duration);
                }

                // 5. Fade new content in
                contentArea.style.opacity = 1;

                // 6. Set timer for the next section
                currentSectionIndex++;
                
                // CRITICAL FIX: Only set the timeout for non-video sections.
                // Video section manages its own flow control via the 'ended' event/fallback timer.
                if (section.type !== 'video' && section.duration < 999999) {
                    setTimeout(nextSection, section.duration);
                }

            }, renderDelay);
        }

        // ‚ö°Ô∏è INITIALIZATION FLOW CONTROL ‚ö°Ô∏è

        // Step 2: Starts the story once audio is confirmed unlocked (Click 2)
        function startCinematicStorySequence() {
            unmuteOverlay.style.opacity = 0;
            
            // üîí REQUEST THE WAKE LOCK HERE (Triggered by Click 2)
            requestWakeLock();

            setTimeout(() => {
                unmuteOverlay.style.display = 'none';
                nextSection();
            }, 1000 + INITIAL_DELAY_AFTER_UNLOCK); // Wait for fade-out + buffer
        }

        // Step 1: Initiated by the *very first* user click.
        function handleFirstTap() {
            if (hasStarted) return;
            hasStarted = true; 

            // IMPORTANT: Remove the click handler immediately to prevent accidental second click
            unmuteOverlay.removeEventListener('click', handleFirstTap);

            // CRITICAL: We run the sequential unlock, which manages the visual feedback (spinner/text change).
            runSequentialUnlock();
        }

        window.onload = function() {
            initializeAudio(); 
            // The first click runs the unlock process (handleFirstTap)
            unmuteOverlay.addEventListener('click', handleFirstTap, { once: true });
            
            // ‚ö†Ô∏è Add event listener to handle Wake Lock if user navigates away and comes back
            document.addEventListener('visibilitychange', () => {
                if (wakeLock !== null && document.visibilityState === 'visible') {
                    // Try to re-acquire the lock if it was lost when hidden
                    requestWakeLock();
                } else if (document.visibilityState === 'hidden' && wakeLock) {
                    // The system often automatically releases the lock when hidden, but the API handles re-acquiring.
                }
            });
        };
    </script>
</body>
</html>